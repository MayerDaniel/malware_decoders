'''
Written by Jason Reaves - @sysopfb
Free to use, attribute properly.

'''
import pefile
import sys
import struct
import aplib
import binascii
import hashlib
import gozi_version

JOINER_SECTIONS = {0xe1285e64: "CRC_PUBLIC_KEY", 0x8fb1dde1: "CRC_CLIENT_INI", 0xd722afcb: "CRC_CLIENT_INI", 0x4f75cea7: "CRC_LOADER_DLL", 0x90f8aab5: "CRC_LOADER_DLL", 0x7a042a8a: "CRC_INSTALL_INI", 0x90f8aab4: "CRC_CLIENT64", 0x30802fd4: "ENCODED_LOADER_DLL", 0x9e154a0c: "CRC_LOADER_DLL"}
INI_PARAMS = {0x4fa8693e: "CRC_SERVERKEY", 0xd0665bf6: "CRC_HOSTS", 0x656b798a: "CRC_GROUP", 0x556aed8f: "CRC_SERVER", 0x11271c7f: "CONF_TIMEOUT", 0x48295783: "CONFIG_FAIL_TIMEOUT", 0xea9ea760: "CRC_BOOTSTRAP", 0x31277bd5: "CRC_TASKTIMEOUT",0x955879a6: "CRC_SENDTIMEOUT", 0x9fd13931: "CRC_BCSERVER", 0x6de85128: "CRC_BCTIMEOUT", 0xacc79a02: "CRC_KNOCKERTIMEOUT", 0x602c2c26: "CRC_KEYLOGLIST", 0x556aed8f: "CRC_SERVER", 0xd7a003c9: "CRC_CONFIGTIMEOUT", 0x18a632bb: "CRC_CONFIGFAILTIMEOUT", 0x73177345: "CRC_DGA_SEED_URL", 0x510f22d2: "CRC_TORSERVER", 0xec99df2e: "CRC_EXTERNALIP", 0xc61efa7a: "CRC_DGATLDS", 0xdf351e24: "CRC_32BITDOWNLOAD", 0x4b214f54: "CRC_64BITDOWNLOAD", 0xcd850e68: "DGA_CRC", 0xdf2e7488: "DGA_COUNT", 0x584e5925: "TIMER"}

class IniParams:
	def __init__(self, count, iniParams):
		self.count = count
		self.ini_params = iniParams
	
	def put_param(self, param):
		self.ini_params.append(param)

	def get_jsonify(self):
		ret_val = {}
		for param in self.ini_params:
			ret_val.update(param.get_jsonify())
		return ret_val
		
	def __str__(self):
		ret_val = ""
		for param in self.ini_params:
			ret_val += str(param)+'\n'
		
		return ret_val

class IniParam:
	def __init__(self, hash, offset, data):
		self.name = "UNKNOWN"
		self.data = ""
		if hash in INI_PARAMS.keys():
			self.name = INI_PARAMS[hash]
		self.data = data[offset:].split('\x00')[0]
		self.hash = hash
	
	def get_name(self):
		return self.name
	def get_data(self):
		return self.data
	
	def get_jsonify(self):
		return({self.name:str(self.data)})

	def __str__(self):
		return(self.name+":"+hex(self.hash)+": "+str(self.data))

def pub_key_parse(data):
	print("PUB KEY:")
	print(binascii.hexlify(data))
	return({"PUB_KEY": binascii.hexlify(data)})

def client_init_parse(data):
	print("INI PARAMS:")
	count = struct.unpack_from('<I', data)[0]
	if count > 50:
		print(binascii.hexlify(data))
		count=min(15,len(data)/0x18)
	params = IniParams(count,[])
	
	data = data[8:]
	for i in range(count):
		if data == '':
			break
		(hash,flag,offset,) = struct.unpack_from('<III', data)
		params.put_param(IniParam(hash,offset,data))
		data = data[0x18:]
	
	print(params)
	return(params.get_jsonify())

def decode_loader_bot(data):
	print("Encoded bot section found")
	decoded = ""
	last_key = 0
	for i in range(len(data)/4):
		temp = struct.unpack_from('<I', data[i*4:])[0]
		temp2 = (temp - last_key) & 0xffffffff
		last_key = temp
		decoded += struct.pack('<I', temp2)
	return(loader_dll_parse(decoded))

def loader_dll_parse(data):
	print("loader_dll_parse called")
	dll_data = {}
	if 'MZ' != data[:2]:
		data = bytearray('MZ\x90\x00'+data[4:])
		pe_off = struct.unpack_from('<H', data[0x3c:])[0]
		data[pe_off] = 'P'
		data[pe_off+1] = 'E'
		data = str(data)
	open('test_outmay.bin','wb').write(data)
	pe = pefile.PE(data=data)
	if pe.OPTIONAL_HEADER.Magic == 0x10b:
		bit = "32"
	else:
		bit = "64"
	print("DLL:")
	print("Bit: "+bit)
	print("MD5: "+hashlib.md5(data).hexdigest())
	dll_data.update({"MD5": hashlib.md5(data).hexdigest()})
	print("SHA256: "+hashlib.sha256(data).hexdigest())
	dll_data.update({"SHA256": hashlib.sha256(data).hexdigest()})
	print("IMPHASH: "+pe.get_imphash())
	dll_data.update({"IMPHASH": pe.get_imphash()})
	ret = parse_ini(data)
	ret.update(dll_data)
	return ({"DLL_"+bit:ret})

def install_ini_parse(data):
	print("CRC_INSTALL_INI: "+binascii.hexlify(data))
	return None

def client_64(data):
	print data[:50]

handlers = {"CRC_PUBLIC_KEY": pub_key_parse, "CRC_CLIENT_INI": client_init_parse, "CRC_LOADER_DLL": loader_dll_parse, "CRC_INSTALL_INI": install_ini_parse, "CRC_CLIENT64": client_64, "ENCODED_LOADER_DLL": decode_loader_bot}

def parse_ini(file_data, ADDON_MAGIC=["JJ", "JF", "J1"]):
	ret_val = {}
	try:
		pe = pefile.PE(data=file_data)
		file_data = pe.get_memory_mapped_image()
	except:
		file_data = bytearray(binascii.unhexlify('4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000') + file_data[60:])
		pe_offset = struct.unpack_from('<I', file_data[60:])[0]
		file_data[pe_offset] = 'P'
		file_data[pe_offset+1] = 'E'
		file_data = str(file_data)
	try:
		pe = pefile.PE(data=file_data)
	except:
		print("Bad PE file")
		return(ret_val)

	#if len(sys.argv) > 2:
	#	ADDON_MAGIC = [sys.argv[2]]
	#else:
	#	ADDON_MAGIC = ["JF", "J1"]
	ver = gozi_version.get_gozi_ver(data)
	if ver != None:
		ret_val["VER"] =  str(ver)


	for magic in ADDON_MAGIC:
		index = 0
		for i in range(3):
			temp = file_data[index:].find(magic)
			if temp != -1:
				index += temp
				(magicVal,offset,length,section,) = struct.unpack_from('<IIII', file_data[index:])
				if length > len(file_data):
					(magicVal,flags,section,offset,length,) = struct.unpack_from('<IIIII', file_data[index:])
				if section in JOINER_SECTIONS.keys():
					print("offset: "+str(offset))
					handler = handlers[JOINER_SECTIONS[section]]
					compressed_data = file_data[offset:offset+length]
					#open(str(section), 'wb').write(compressed_data)
					if len(compressed_data) > 0:
						uncompressed = ""
						try:
							uncompressed = aplib.decompress(compressed_data).do()
							uncompressed = uncompressed[0]
							print("Calling handler")
							ret = handler(uncompressed)
							if ret != None:
								ret_val.update(ret)
						except:
							print("SECTION:"+hex(section)+":DECOMPRESS FAILURE Size:" + str(len(compressed_data)))
							ret = handler(compressed_data)
							if ret != None:
								ret_val.update(ret)
				else:
					try:
						compressed_data = file_data[offset:offset+length]
						#open(hex(section)+'_blahblah.bin', 'wb').write(compressed_data)
						uncompressed = aplib.decompress(compressed_data).do()
						if uncompressed[0][:2] == 'MZ':
							ret = loader_dll_parse(uncompressed[0])
							if ret != None:
								ret_val.update(ret)
						else:
							print("UNKNOWN SECTION: " +hex(section))
					except:
						print("UNKNOWN SECTION: " +hex(section))
				index += 1
			else:
				break
	print(ret_val)
	return ret_val
		

if __name__ == "__main__":
	data = open(sys.argv[1],'rb').read()
	r = parse_ini(data)
